

# 贪心算法




[TOC]

- 在对问题求解时，总是做出在当前看来最好的选择
- 不从整体最优上加以考虑，所做出的仅是某种意义上的局部最优解
- 对范围相当广泛的许多问题能产生整体最优解或整体最优解的近似解

贪心算法不适合解决的问题：

```c++
//前面的选择会影响后面选择的问题
```

```c++
一些知识点补充：   `        

/**其实贪心算法是一种特殊的动态规划，由于其具有贪心选择性质，保证了子问题只会被计算一次，不会被多次计算，因此贪心算法其实是最简单的动态规划。**

**在动态规划算法中，每步所作的选择往往依赖于相关子问题的解。因而只有在解出相关子问题后，才能作出选择。而在贪心算法中，仅在当前状态下作出最好选择，
即局部最优选择。然后再去解作出这个选择后产生的相应的子问题。**

**动态规划的动机是消除递归过程中产生的大量重叠子问题, 两种方法 : 记忆化搜索 和 自底向上递推.**

**最优子结构, 在问题转化为子问题时, 原问题最优当且仅当子问题最优.**/
    
背包问题：
    动态规划与分治法类似，都是把大问题拆分成小问题，通过寻找大问题与小问题的递推关系，解决一个个小问题，最终达到解决原问题的效果。
    但不同的是，分治法在子问题和子子问题等上被重复计算了很多次，而动态规划则具有记忆性，
    还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)=m
```

​                         

## 背包问题

|   商品编号i    |  1   |  2   |  3   |  4   |
| :------------: | :--: | :--: | :--: | :--: |
| 体积（weight） |  2   |  3   |  4   |  5   |
| 价值（value）  |  3   |  4   |  5   |  6   |

| 商品编号/背包容量 |  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
| :---------------: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|         0         |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
|         1         |  0   |  0   |  3   |  3   |  3   |  3   |  3   |  3   |  3   |
|         2         |  0   |  0   |  3   |  4   |  4   |  7   |  7   |  7   |  7   |
|         3         |  0   |  0   |  3   |  4   |  5   |  7   |  8   |  9   |  9   |
|         4         |  0   |  0   |  3   |  4   |  5   |  7   |  8   |  9   |  10  |

- 物体编号和背包容量从0开始，不是为了方便循环书写，而是为了在进行状态转换方程方面的时候用于比较·



### 解法归纳

- 如果装不下当前物品，那么前n个物品的最佳组合和前n-1个物品的最佳组合是一样的
- 如果装得下当前物品：

**假设1：**装当前物品，在给当前物品预留了相应空间的情况下，前n-1个物品的最佳组合是一样的

**假设2：**不装当前物品，那么前n个物品的最佳组合和前n-1个物品的最佳组合是一样的

选取假设1和假设2中较大的价值，为当前最佳组合的价值；



### 回溯

**在使得背包内总价值最大的情况下，背包内装了哪些物品？**

```c++
/*归纳：

从表的右下角开始回溯，如果发现前n个物品最佳组合的价值和前n-1个物品最佳组合的价值一样，

说明前n个物品没有被装入；否则，前n个物品被装入
```



#### bag.cpp

```c++
#include<iostream>
#include <algorithm>
using namespace std;

							//商品的编号1、2、3、4
int weight[5] = { 0 , 2 , 3 , 4 , 5 };			//商品的体积2、3、4、5
int value[5] = { 0 , 3 , 4 , 5 , 6 };			//商品的价值3、4、5、6
int bagV = 8;					        //背包大小
int dp[5][9] = { { 0 } };			        //动态规划表
int item[5];					        //最优解情况

//这里如果未排序的话，排一下序先
void findMax() {					//动态规划
	for (int i = 1; i <= 4; i++) {		//i表示物品编号
		for (int j = 1; j <= bagV; j++) {	//j表示当前背包容量，列表时i为列号，j为行号
			if (j < weight[i])
				dp[i][j] = dp[i - 1][j];
			else
				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
			/*否则，装当前物品，在给当前物品预留了相应空间的情况下，前n-1个物品的最佳组合加上
			  当前物品的价值就是总价值*/
			/*其实，如果装了当前物品的情况下，只剩j-weight[i]的容量了，如果物品是按容量大小排序的话只需找出
			<=j-weight[i]容量大小的物品，并在其中找出最优解最好了，说前n-1个物品也ok，但如果是有序排列的话，这个范围还是说大了
			不过代码实现这样是比较麻烦的，直接n-1就好了，而且无逻辑错误，找的话也更加仔细 */
			//看到下面的代码实现，确实是只在 <=j-weight[i]容量大小的物品中查找，而且从i-1、j-weight[i]开始可以正确高效的查找到
			//表中信息，然后从下而上查找到放入背包中的物品
		}
	}
}

void findWhat(int i, int j) {				//最优解情况，回溯
	if (i >= 0) {
		if (dp[i][j] == dp[i - 1][j]) {
			item[i] = 0;
			findWhat(i - 1, j);	//标记未放入背包中的物品为0，然后竖直向上查找放入背包中的物品
		}
		else if (j - weight[i] >= 0 && dp[i][j] == dp[i - 1][j - weight[i]] + value[i]) {
			item[i] = 1;
			findWhat(i - 1, j - weight[i]);	//查找到了标记为1，继续查找下一位放入背包中的物品
							//从表尾（右下角）回溯到表头（左上角），结束
		}
	}
}

void print() {
	for (int i = 0; i < 5; i++) {			//动态规划表输出
		for (int j = 0; j < 9; j++) {
			cout << dp[i][j] << ' ';
		}
		cout << endl;
	}
	cout << endl;

	for (int i = 0; i < 5; i++)	{		//最优解输出
		cout << item[i] << ' ';
	}
	cout << endl << endl;

	for (int i = 0; i < 5; i++) {
		if (item[i] == 1) {
			cout << "编号【" << i << "】已放入背包" << endl << endl;
		}
	}

}

```

#### Main.cpp

```c++
int main()
{
    //int array[8] = { 2,0,0,5,2,0,3,7 };
	//试一下sort函数
	//sort(array, array + 4);		//输出结果为：0 0 2 5 2 0 3 7，说明array+4不是array[0+4],而是表示排序到第四位
						//其实可以使用容器，用array.begin到array.end,如果是要一整个排序的话，就不用去在意有几个元素了
	//for (int k = 0; k < 8; k++) {
	//	cout << array[k] << ' ';
	//}cout << endl;
    
	//问题详细
	cout << endl << "商品编号：1  2  3  4" << endl;
	cout << "商品体积：2  3  4  5" << endl;
	cout << "商品价值：3  4  5  6" << endl << endl;
	findMax();
	findWhat(4, 8);
	print();

	return 0;
}
```



#### Debug_running_diagram

```c++

商品编号：1  2  3  4
商品体积：2  3  4  5
商品价值：3  4  5  6

0 0 0 0 0 0 0 0 0
0 0 3 3 3 3 3 3 3
0 0 3 4 4 7 7 7 7
0 0 3 4 5 7 8 9 9
0 0 3 4 5 7 8 9 10

0 0 1 0 1

编号【2】已放入背包

编号【4】已放入背包


D:\学习类文件夹\源代码\贪心算法\Debug\贪心算法.exe (进程 7124)已退出，返回代码为: 0。
若要在调试停止时自动关闭控制台，请启用“工具”->“选项”->“调试”->“调试停止时自动关闭控制台”。
按任意键关闭此窗口...
```



### 分糖果

##### candy.java

```java
package com.Bennnnnnn.贪心;
import java.util.Arrays

public class FindContentChildren {
    
    static int solution(int[]children,int[]candies) {
        Arrays.sort(chilren);
        Arrays.sort(candies);
        int child = 0;	//能吃饱的孩子数量
        int candy = 0;
        while(child < children.length && candy < candies.length) {
            if (chilrden[child] <= candies[candy++])	child++;
        }
        return child;
    }
}
```



