# 基数排序_string



[TOC]

## 1.LSD基数排序（LSD radix sort ）

　　现在开始讲String排序算法。

　　LSD全称：Least-signiﬁcant-digit-ﬁrst 低位有效数字优先。

　　如果**要排序的那堆字符串长度相同**，我们可以用LSD基数排序。

　　从例子入手：a[]是拥有一堆只有三个字符的string数组。

　　![img](https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190203163203577-1394959604.png)

　　为了方便理解，我把这些字符都特意分开标示出来了。a[0]=dab;a[1]=add;a[2]=cab; ...
　　首先，我们先对第三个字符那一列通过**键索引计数法**把这堆字符串排一次序：

　　![img](https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190203163644978-827903413.png)

　　理所当然的，因为这些字符串每个都是一个个体，排序的时候，要整个字符串一起移动而不是只移动第三个字符。

　　标红的那一列已经排好序了。

　　接下来对第二个字符那一列通过键索引计数法把这堆字符串排一次序：

　　![img](https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190203164248183-1446575526.png)

　　接下来对第一个字符那一列通过键索引计数法把这堆字符串排一次序：

　　![img](https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190203171248979-501845707.png)

　　排序完成，算法结束。

### 稳定性问题：

　　在这里，我们可以讨论一下稳定性的问题了（stable）。我们经常说这个算法是稳定的（stable），那个算法是不稳定的（not stable）。

　　这里的稳定不是指可不可靠，而是指这个算法会不会破坏原有的顺序。

　　例如，我们看一下这个例子，经历了**对第二个字符那一列通过键索引计数法把这堆字符串排一次序后**，a[1]=cab; a[2]=fad。

　　它们在**对第三个字符那一列通过键索引计数法把这堆字符串排一次序**的那时，对应的位置在哪？a[1]=cab; a[4]=fad。

　　第一次排序时，cab在fad前面，因为它们的第三个字符b<d; 但第二次排序时，这两个字符串的第二个字符都是a,不稳定的算法有可能会把fad排到cab前面，但稳定的算法肯定不会！

　　总结一下LSD基数排序通用思路就是：

　　如果需要排序的那堆字符串拥有一样多的字符，那么我们可以从它们的最后一个字符进行键索引计数法排序，然后对它们的倒数第二个字符进行键索引计数法排序，如此类推，直到对它们的第一个字符进行键索引计数法排序后，排序结束。

### 键索问题：

　　但是，**键索引计数法**是需要知道要排序的字符串有多少个不同的字符的，从而给那些字符匹配键索，难道我们每次都要去数一下有多少个不同的字符？

　　其实并不需要，这样做太耗费时间了。看下表：

　　![img](https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190203172813163-1627520051.png)

　　根据每个不同类型的字符串，我们可以选择不同的R值（**键索引计数法**构建count数组需要用到的R值）。

　　如果我们知道要排序的字符串都是由小写字母组成，则R=26(毕竟只有26个字母)；

　　如果要排序的字符串还有一些符号，那就用R=256吧。

　　总之，按照需求选择R值。

 

#### 代码实现:

　　![img](https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190203173350406-785273615.png)

 

## 2.MSD基数排序（MSD radix sort ）

　　那么如果**要排序的那堆字符串长度不同**，怎么办？那就用MSD基数排序吧！

　　MSD全称：Most-signiﬁcant-digit-ﬁrst 高位有效数字优先。

　　LSD是从最后一位字符开始往前排序的，而MSD是从第一位字符开始往后排序的。

　　从例子入手：a[]是拥有一堆字符串的字符串数组。

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212112939991-182703335.png" alt="img" style="zoom:150%;" />

　　为了方便理解，我把这些字符都特意分开标示出来了。a[0]=she;a[1]=sells;a[2]=seashells; ...

 　我们设定每个字符串的最后一位字符的下一个位置的空字符的键索为-1，即：（为了方便观察，这里将暂时标红它们）

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212142659779-2128478924.png" alt="img" style="zoom:150%;" />

　　每次进行**键索引计数法排序**时，我们都按照排序结果，把所有字符串分成数个区。如下：

　　首先，我们先对第一个字符那一列通过**键索引计数法**把这堆字符串排一次序：

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212150437952-1514195661.png" alt="img" style="zoom:150%;" />

　　第一个字符那一列只有4个不同的字母，故把所有字符串分为4个区：

　　第一个区有a[0]；第二个区有a[1]；第三个区有a[2]~a[11]；第四个区有a[12]、a[13]。

　　然后从上往下看：

　　第一个区只有一个字符串，此区排序完毕；

　　第二个区只有一个字符串，此区排序完毕；

　　第三个区有很多个字符串，对此区的第二个字符那一列通过**键索引计数法**把这堆字符串排一次序：（为了方便观察，已排序完毕的字符串用绿色表示）

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212152419875-1507835975.png" alt="img" style="zoom:150%;" />

 

　　继续分区：

　　第一个区有a[2]~a[6];第二个区有a[7]~a[10];第三个区有a[11]。

　　然后从上往下看：

　　第一个区有很多个字符串，对此区的第三个字符那一列通过**键索引计数法**把这堆字符串排一次序：（为了方便观察，待排序的字符串用黑色表示）

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212153230636-911319161.png" alt="img" style="zoom:150%;" />

　　继续分区：

　　第一个区有a[2]~a[4];第二个区有a[5]、a[6]。

　　然后从上往下看：

　　第一个区有很多个字符串，对此区的第四个字符那一列通过**键索引计数法**把这堆字符串排一次序：

 　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212153752489-1292253912.png" alt="img" style="zoom:150%;" />

　　在这次排序中，-1的效果就能表现出来了：因为分配键索时，字符分到的键索都是正数，这里的-1是最小的，故这样可以保证最短的字符在最前面。

　　继续分区：只有一个区，此区有a[3]、a[4]。（-1不是字符，不参与分区）

　　此区有很多个字符串，对此区的第五个字符那一列通过**键索引计数法**把这堆字符串排一次序：

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212154254631-194156342.png" alt="img" style="zoom:150%;" />

　　继续分区：只有一个区，此区有a[3]、a[4]。

　　此区有很多个字符串，对此区的第六个字符那一列通过**键索引计数法**把这堆字符串排一次序：

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212154728088-892974413.png" alt="img" style="zoom:150%;" />

　　（由于这两个字符串是相同的，故每次排序后的结果都一样，这里省略第7、8个字符的排序）

　　继续分区：只有一个区，此区有a[3]、a[4]。

　　此区有很多个字符串，对此区的第九个字符那一列通过**键索引计数法**把这堆字符串排一次序：

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212154902372-1616163854.png" alt="img" style="zoom:150%;" />

　　继续分区：只有一个区，此区有a[3]、a[4]。

　　此区有很多个字符串，对此区的第十个字符那一列通过**键索引计数法**把这堆字符串排一次序：

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212155116399-1194090115.png" alt="img" style="zoom:150%;" />

　　继续分区：没有区（因为都是-1，-1不是字符，不参与分区）

　　此区排序完毕，开始下一个区的排序：

　　此区有很多个字符串，对此区的第四个字符那一列通过**键索引计数法**把这堆字符串排一次序：

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212155532376-1211535606.png" alt="img" style="zoom:150%;" />

　　继续分区：只有一个区，此区有a[5]、a[6]。

　　此区有很多个字符串，对此区的第五个字符那一列通过**键索引计数法**把这堆字符串排一次序：

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212155642316-1351707138.png" alt="img" style="zoom:150%;" />

　　继续分区：只有一个区，此区有a[5]、a[6]。

　　此区有很多个字符串，对此区的第六个字符那一列通过**键索引计数法**把这堆字符串排一次序：

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212155722563-1626243757.png" alt="img" style="zoom:150%;" />

　　继续分区：没有区（因为都是-1，-1不是字符，不参与分区）

　　此区排序完毕，开始下一个区的排序：

　　此区有很多个字符串，对此区的第三个字符那一列通过**键索引计数法**把这堆字符串排一次序：

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212155918441-514415598.png" alt="img" style="zoom:150%;" />

　　继续分区：

　　第一个区有a[7]~a[9];第二个区有a[10]。

　　然后从上往下看：

　　第一个区有很多个字符串，对此区的第四个字符那一列通过**键索引计数法**把这堆字符串排一次序：

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212160116581-730718569.png" alt="img" style="zoom:150%;" />

　　继续分区：只有一个区，此区有a[8]。（-1不是字符，不参与分区）

　　此区只有一个字符串，此区排序完毕。

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212160406127-376500475.png" alt="img" style="zoom:150%;" />

　　开始下一个区的排序：

　　此区只有一个字符串，此区排序完毕。

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212160425023-722687300.png" alt="img" style="zoom:150%;" />

　　开始下一个区的排序：

　　此区只有一个字符串，此区排序完毕。

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212160446771-2077282298.png" alt="img" style="zoom:150%;" />

　　开始下一个区的排序：

　　此区有两个字符串，但由于它们是一样的，故这里省略对此区的第二、第三、第四个字符那一列分别通过**键索引计数法**排序：

　　<img src="https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212160730645-316237677.png" alt="img" style="zoom:150%;" />

　　没有下一个区了，全部排序完毕，算法结束。

　　这个算法演示过程本身就是一个递归的过程。

　　**总结一下：**

　　1. 对所有字符串的第一个字符那一列通过**键索引计数法**把这堆字符串排一次序，根据排序结果进行分区；

　　2. 从上往下处理各个分区：如果分区只有一个字符串，则此区处理完毕；如果有多个字符串，则对此区的字符串的下一个字符进行排序、分区、处理分区。

  3. 所有分区处理完后，排序完毕，算法结束。

     

#### 代码实现：

　　![img](https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212162347559-358753204.png)

　　![img](https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212162407861-761171718.png)

 

## 3.LSD和MSD的算法效率

　　![img](https://img2018.cnblogs.com/blog/1534783/201902/1534783-20190212165945682-1549975572.png)

　　

**注释：**

　　N为要排序的元素个数。

　　LSD的W: 由于LSD只针对于**要排序的那堆字符串长度相同**，故W为字符串的长度。

　　MSD的W: 要排序的那堆字符串的长度平均值。

　　guarantee: 算法保证能在多少次操作后完成。

　　random: 如果要排序的数组里的元素顺序是随机的，则算法可以在多少次操作后完成。

　　extra space: 算法需要的额外空间。

 

## 4.MSD算法的缺陷

　　1. MSD算法需要额外空间（**键索引计数法每次排序都需要使用额外空间**），这意味着浪费内存。

　　2. 递归循环里的每次循环都需要进行很多操作。

　　将把MSD算法和快速排序法结合起来，形成更高效率的算法: **3区基数快速排序（3-way radix quicksort）**